{"name":"Foobarmotor","tagline":"Exercício 7 de 8 da Lista de Padrões de Projeto","body":"## Cadeia de Responsabilidade\r\n\r\nO padrão Chain of Responsibility possui a seguinte intenção:\r\n\r\n> “Evitar o acoplamento do remetente de uma solicitação ao seu receptor, ao dar a mais de um objeto a oportunidade de tratar a solicitação. Encadear os objetos receptores, passando a solicitação ao longo da cadeia até que um objeto a trate.” GAMMA, Erich et al. Padrões de Projeto: Soluções reutilizáveis de software orientado a objetos.\r\n\r\n### Diagrama\r\n\r\nSegue o diagrama correspondente a implementação feita nesse projeto utilizando o padrão\r\n\r\n![](https://github.com/izabely-furtado/FoobarMotor/blob/master/diagramas/DiagramCadeiaResponsabilidade.png?raw=true)\r\n\r\n### Explicação\r\n\r\nPrimeiramente foi feita uma enumeração das direções possíveis na classe **DirecaoEnum** para facilitar o entendimento sem números mágicos.\r\n\r\nAssim foi feito a interface **IMapa** que padronizasse os métodos que deveriam ser implementados, não só isso, essa representa os tipos de todos os elementos em **Mapa** pois esses devem obrigatoriamente possuir todas essas funções.\r\n\r\nAs funções da interface são referentes e recuperação e inserção de novos elementos em cada uma das direções, a recuperação do nome da cidade atual e do processamento dos dados estando em cada uma das cidades do mapa.\r\n\r\nA implementação primordial trata-se de **processaConteudo**, tanto que os testes foram feitos primordial nessa função e nas que esta usava, esta função pega como entrada uma lista de cidades e uma direção e retorna, qual das cidades da lista está mais próxima se acabar seguindo  aquela determinada direção. Assim como mostrado no código abaixo:\r\n\r\n`@Override\r\n\r\n\r\n    public IMapa processaConteudo(List<String> cidades, Integer direcao) {\r\n        boolean cidadeEncontrada =  false;\r\n        //se o conteudo estiver vazio\r\n        if (this.cidadesCorrespondentes().isEmpty()){\r\n            cidadeEncontrada = false;\r\n        }\r\n        //verifica se o conteudo pode estar dentre as cidades diretamente mais proximas \r\n        else{\r\n            if(cidades.contains(this.cidadesCorrespondentes().get(direcao))){\r\n                cidadeEncontrada = true;\r\n            }\r\n        }\r\n        //se proximo ao objeto\r\n        if (cidadeEncontrada){\r\n            return this.getCidade(direcao);\r\n        }\r\n        //procura se esta mais longe, mas na mesma direção\r\n        else{\r\n            if (this.getCidade(direcao) != null){\r\n                return this.getCidade(direcao).processaConteudo(cidades, direcao);\r\n            }\r\n            else{\r\n                throw new RuntimeException(\"Nenhuma das cidades indicadas fica nessa direção\");\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n`\r\n\r\nOutro ponto a ser considerado são a funções abstradas em **Mapa**, são estas **cidadesCorrespondente** e **processaAqui**, a primeira representa um HashMap correlacionando a direção e qual cidade esta mais próxima naquela direção e a segunda imprime o nome da cidade atual.\r\n\r\n\r\n### Motivação\r\n\r\n* Acaba com as estruturas de decisão\r\n* Faz com que cada classe identifique o problema e só processe se for com ela, se a carapuça servir\r\n\r\n## Interpretador\r\n\r\n### Explicação\r\n\r\n### Motivação\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}