{"name":"Foobarmotor","tagline":"Exercício 7 de 8 da Lista de Padrões de Projeto","body":"## Cadeia de Responsabilidade\r\n\r\nO padrão Chain of Responsibility possui a seguinte intenção:\r\n\r\n> “Evitar o acoplamento do remetente de uma solicitação ao seu receptor, ao dar a mais de um objeto a oportunidade de tratar a solicitação. Encadear os objetos receptores, passando a solicitação ao longo da cadeia até que um objeto a trate.” GAMMA, Erich et al. Padrões de Projeto: Soluções reutilizáveis de software orientado a objetos.\r\n\r\n### Diagrama\r\n\r\nSegue o diagrama correspondente a implementação feita nesse projeto utilizando o padrão\r\n\r\n![](https://github.com/izabely-furtado/FoobarMotor/blob/master/diagramas/DiagramCadeiaResponsabilidade.png?raw=true)\r\n\r\n### Explicação\r\n\r\nPrimeiramente foi feita uma enumeração das direções possíveis na classe **DirecaoEnum** para facilitar o entendimento sem números mágicos.\r\n\r\nAssim foi feito a interface **IMapa** que padronizasse os métodos que deveriam ser implementados, não só isso, essa representa os tipos de todos os elementos em **Mapa** pois esses devem obrigatoriamente possuir todas essas funções.\r\n\r\nAs funções da interface são referentes e recuperação e inserção de novos elementos em cada uma das direções, a recuperação do nome da cidade atual e do processamento dos dados estando em cada uma das cidades do mapa.\r\n\r\nA implementação primordial trata-se de **processaConteudo**, tanto que os testes foram feitos primordial nessa função e nas que esta usava, esta função pega como entrada uma lista de cidades e uma direção e retorna, qual das cidades da lista está mais próxima se acabar seguindo  aquela determinada direção. Assim como mostrado no código abaixo:\r\n\r\n`@Override\r\n\r\n\r\n    public IMapa processaConteudo(List<String> cidades, Integer direcao) {\r\n        boolean cidadeEncontrada =  false;\r\n        //se o conteudo estiver vazio\r\n        if (this.cidadesCorrespondentes().isEmpty()){\r\n            cidadeEncontrada = false;\r\n        }\r\n        //verifica se o conteudo pode estar dentre as cidades diretamente mais proximas \r\n        else{\r\n            if(cidades.contains(this.cidadesCorrespondentes().get(direcao))){\r\n                cidadeEncontrada = true;\r\n            }\r\n        }\r\n        //se proximo ao objeto\r\n        if (cidadeEncontrada){\r\n            return this.getCidade(direcao);\r\n        }\r\n        //procura se esta mais longe, mas na mesma direção\r\n        else{\r\n            if (this.getCidade(direcao) != null){\r\n                return this.getCidade(direcao).processaConteudo(cidades, direcao);\r\n            }\r\n            else{\r\n                throw new RuntimeException(\"Nenhuma das cidades indicadas fica nessa direção\");\r\n            }\r\n        }\r\n        \r\n    }\r\n`\r\n\r\nOutro ponto a ser considerado são a funções abstradas em **Mapa**, são estas **cidadesCorrespondente** e **processaAqui**, a primeira representa um HashMap correlacionando a direção e qual cidade esta mais próxima naquela direção e a segunda imprime o nome da cidade atual.\r\n\r\n\r\n### Motivação\r\n\r\n* Acaba com as estruturas de decisão\r\n* Faz com que cada classe identifique o problema e só processe se for com ela, se a carapuça servir\r\n\r\n## Interpretador\r\n\r\nVejamos a intenção do padrão:\r\n\r\n> “Dada uma linguagem, definir uma representação para sua gramática juntamente com um interpretador que usa a representação para interpretar sentenças dessa linguagem.” GAMMA, Erich et al. Padrões de Projeto: Soluções reutilizáveis de software orientado a objetos.\r\n\r\n###Explicação\r\n\r\nO Contexto foi definido na classe **Contexto**, esse possui uma entrada e uma saída, essa entrada é processada no construtor gerando uma saída correspondente, de acordo com o modo que esta entrada foi interpretada\r\n\r\nO interpretador da entrada foi feito pelo AntlrWorks2, por lá é feita a gramática **Foobar.g4** que gera o Lexer e o Parser necessários para a interpretação, dado isso é necessária o uso da biblioteca do **antlr4-4.0-complete-sources.jar**, pois o uso efetiva uma dependência a esta biblioteca, como pode ser notado pelo código do **Contexto** a seguir:\r\n\r\n`\r\npublic class Contexto {\r\n\r\n    String input;\r\n    IMapa output;\r\n    \r\n    public Contexto(String entra){\r\n        this.input = entra;\r\n        CharStream entrada = new ANTLRInputStream(this.input);\r\n        \r\n        //ANTLRInputStream input = new ANTLRInputStream(System.in);\r\n        FoobarLexer lexer = new FoobarLexer(entrada);\r\n        CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n        FoobarParser parser = new FoobarParser(tokens);\r\n        \r\n        if (parser.prog().result != null) {\r\n            this.output = parser.prog2().result;\r\n        }\r\n        else {\r\n            throw new RuntimeException(\"!!! Error\");\r\n        }\r\n   }\r\n\r\n}\r\n` \r\n\r\n### Motivação\r\n\r\n* Fornece uma maneira de tomar decisões com um fraco acoplamento. \r\n\r\n* É possível variar praticamente todos os componentes sem grandes danos ao projeto. \r\n\r\n* Cada elemento implementa sua própria maneira de responder a requisição, e estas podem ser alteradas facilmente.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}